{"version":3,"file":"utils.cjs.production.min.js","sources":["../src/math.ts","../src/canned.ts","../src/sla.ts","../src/helpers.ts","../src/typingStatus.ts","../src/debounce.ts","../src/string.ts"],"sourcesContent":["/**\n * Sorts an array of numbers in ascending order.\n * @param {number[]} arr - The array of numbers to be sorted.\n * @returns {number[]} - The sorted array.\n */\nexport function sortAsc(arr: number[]) {\n  // .slice() is used to create a copy of the array so that the original array is not mutated\n  return arr.slice().sort((a, b) => a - b);\n}\n\n/**\n * Calculates the quantile value of an array at a specified percentile.\n * @param {number[]} arr - The array of numbers to calculate the quantile value from.\n * @param {number} q - The percentile to calculate the quantile value for.\n * @returns {number} - The quantile value.\n */\nexport function quantile(arr: number[], q: number) {\n  const sorted = sortAsc(arr); // Sort the array in ascending order\n  return _quantileForSorted(sorted, q); // Calculate the quantile value\n}\n\n/**\n * Clamps a value between a minimum and maximum range.\n * @param {number} min - The minimum range.\n * @param {number} max - The maximum range.\n * @param {number} value - The value to be clamped.\n * @returns {number} - The clamped value.\n */\nexport function clamp(min: number, max: number, value: number) {\n  if (value < min) {\n    return min;\n  }\n  if (value > max) {\n    return max;\n  }\n  return value;\n}\n\n/**\n * This method assumes the the array provided is already sorted in ascending order.\n * It's a helper method for the quantile method and should not be exported as is.\n *\n * @param {number[]} arr - The array of numbers to calculate the quantile value from.\n * @param {number} q - The percentile to calculate the quantile value for.\n * @returns {number} - The quantile value.\n */\nfunction _quantileForSorted(sorted: number[], q: number) {\n  const clamped = clamp(0, 1, q); // Clamp the percentile between 0 and 1\n  const pos = (sorted.length - 1) * clamped; // Calculate the index of the element at the specified percentile\n  const base = Math.floor(pos); // Find the index of the closest element to the specified percentile\n  const rest = pos - base; // Calculate the decimal value between the closest elements\n\n  // Interpolate the quantile value between the closest elements\n  // Most libraries don't to the interpolation, but I'm just having fun here\n  // also see https://en.wikipedia.org/wiki/Quantile#Estimating_quantiles_from_a_sample\n  if (sorted[base + 1] !== undefined) {\n    // in case the position was a integer, the rest will be 0 and the interpolation will be skipped\n    return sorted[base] + rest * (sorted[base + 1] - sorted[base]);\n  }\n\n  // Return the closest element if there is no interpolation possible\n  return sorted[base];\n}\n\n/**\n * Calculates the quantile values for an array of intervals.\n * @param {number[]} data - The array of numbers to calculate the quantile values from.\n * @param {number[]} intervals - The array of intervals to calculate the quantile values for.\n * @returns {number[]} - The array of quantile values for the intervals.\n */\nexport const getQuantileIntervals = (data: number[], intervals: number[]) => {\n  // Sort the array in ascending order before looping through the intervals.\n  // depending on the size of the array and the number of intervals, this can speed up the process by at least twice\n  // for a random array of 100 numbers and 5 intervals, the speedup is 3x\n  const sorted = sortAsc(data);\n\n  return intervals.map(interval => {\n    return _quantileForSorted(sorted, interval);\n  });\n};\n","import {\n  Conversation,\n  Sender,\n  Variables,\n  CustomAttributes,\n  Contact,\n} from './types/conversation';\nconst MESSAGE_VARIABLES_REGEX = /{{(.*?)}}/g;\n\nconst skipCodeBlocks = (str: string) => str.replace(/```(?:.|\\n)+?```/g, '');\n\nexport const capitalizeName = (name: string | null) => {\n  return (name || '').replace(/\\b(\\w)/g, s => s.toUpperCase());\n};\n\nexport const getFirstName = ({ user }: { user: Sender }) => {\n  const firstName = user?.name ? user.name.split(' ').shift() : '';\n  return capitalizeName(firstName as string);\n};\n\nexport const getLastName = ({ user }: { user: Sender }) => {\n  if (user && user.name) {\n    const lastName =\n      user.name.split(' ').length > 1 ? user.name.split(' ').pop() : '';\n    return capitalizeName(lastName as string);\n  }\n  return '';\n};\n\nexport const getMessageVariables = ({\n  conversation,\n  contact,\n}: {\n  conversation: Conversation;\n  contact?: Contact;\n}) => {\n  const {\n    meta: { assignee, sender },\n    id,\n    custom_attributes: conversationCustomAttributes = {},\n  } = conversation;\n  const { custom_attributes: contactCustomAttributes } = contact || {};\n\n  const standardVariables = {\n    'contact.name': capitalizeName(sender?.name || ''),\n    'contact.first_name': getFirstName({ user: sender }),\n    'contact.last_name': getLastName({ user: sender }),\n    'contact.email': sender?.email,\n    'contact.phone': sender?.phone_number,\n    'contact.id': sender?.id,\n    'conversation.id': id,\n    'agent.name': capitalizeName(assignee?.name || ''),\n    'agent.first_name': getFirstName({ user: assignee }),\n    'agent.last_name': getLastName({ user: assignee }),\n    'agent.email': assignee?.email ?? '',\n  };\n  const conversationCustomAttributeVariables = Object.entries(\n    conversationCustomAttributes ?? {}\n  ).reduce((acc: CustomAttributes, [key, value]) => {\n    acc[`conversation.custom_attribute.${key}`] = value;\n    return acc;\n  }, {});\n\n  const contactCustomAttributeVariables = Object.entries(\n    contactCustomAttributes ?? {}\n  ).reduce((acc: CustomAttributes, [key, value]) => {\n    acc[`contact.custom_attribute.${key}`] = value;\n    return acc;\n  }, {});\n\n  const variables = {\n    ...standardVariables,\n    ...conversationCustomAttributeVariables,\n    ...contactCustomAttributeVariables,\n  };\n\n  return variables;\n};\n\nexport const replaceVariablesInMessage = ({\n  message,\n  variables,\n}: {\n  message: string;\n  variables: Variables;\n}) => {\n  // @ts-ignore\n  return message?.replace(MESSAGE_VARIABLES_REGEX, (_, replace) => {\n    return variables[replace.trim()]\n      ? variables[replace.trim().toLowerCase()]\n      : '';\n  });\n};\n\nexport const getUndefinedVariablesInMessage = ({\n  message,\n  variables,\n}: {\n  message: string;\n  variables: Variables;\n}) => {\n  const messageWithOutCodeBlocks = skipCodeBlocks(message);\n  const matches = messageWithOutCodeBlocks.match(MESSAGE_VARIABLES_REGEX);\n  if (!matches) return [];\n\n  return matches\n    .map(match => {\n      return match\n        .replace('{{', '')\n        .replace('}}', '')\n        .trim();\n    })\n    .filter(variable => {\n      return variables[variable] === undefined;\n    });\n};\n","import { Conversation } from './types/conversation';\nimport { AppliedSla, SLAStatus } from './types/sla';\n\n/**\n * Calculates the threshold for an SLA based on the current time and the provided threshold.\n * @param timeOffset - The time offset in seconds.\n * @param threshold - The threshold in seconds or null if not applicable.\n * @returns The calculated threshold in seconds or null if the threshold is null.\n */\nconst calculateThreshold = (\n  timeOffset: number,\n  threshold: number | null\n): number | null => {\n  // Calculate the time left for the SLA to breach or the time since the SLA has missed\n  if (threshold === null) return null;\n  const currentTime = Math.floor(Date.now() / 1000);\n  return timeOffset + threshold - currentTime;\n};\n\n/**\n * Finds the most urgent SLA status based on the threshold.\n * @param SLAStatuses - An array of SLAStatus objects.\n * @returns The most urgent SLAStatus object.\n */\nconst findMostUrgentSLAStatus = (SLAStatuses: SLAStatus[]): SLAStatus => {\n  // Sort the SLAs based on the threshold and return the most urgent SLA\n  SLAStatuses.sort(\n    (sla1, sla2) => Math.abs(sla1.threshold) - Math.abs(sla2.threshold)\n  );\n  return SLAStatuses[0];\n};\n\n/**\n * Formats the SLA time in a human-readable format.\n * @param seconds - The time in seconds.\n * @returns A formatted string representing the time.\n */\nconst formatSLATime = (seconds: number): string => {\n  const units: { [key: string]: number } = {\n    y: 31536000, // 60 * 60 * 24 * 365\n    mo: 2592000, // 60 * 60 * 24 * 30\n    d: 86400, // 60 * 60 * 24\n    h: 3600, // 60 * 60\n    m: 60,\n  };\n\n  if (seconds < 60) {\n    return '1m';\n  }\n\n  // we will only show two parts, two max granularity's, h-m, y-d, d-h, m, but no seconds\n  const parts: string[] = [];\n\n  Object.keys(units).forEach(unit => {\n    const value = Math.floor(seconds / units[unit]);\n    if (seconds < 60 && parts.length > 0) return;\n    if (parts.length === 2) return;\n    if (value > 0) {\n      parts.push(value + unit);\n      seconds -= value * units[unit];\n    }\n  });\n  return parts.join(' ');\n};\n\n/**\n * Creates an SLA object based on the type, applied SLA, and chat details.\n * @param type - The type of SLA (FRT, NRT, RT).\n * @param appliedSla - The applied SLA details.\n * @param chat - The chat details.\n * @returns An object containing the SLA status or null if conditions are not met.\n */\nconst createSLAObject = (\n  type: string,\n  appliedSla: AppliedSla,\n  chat: Conversation\n): { threshold: number | null; type: string; condition: boolean } | null => {\n  const {\n    sla_first_response_time_threshold: frtThreshold,\n    sla_next_response_time_threshold: nrtThreshold,\n    sla_resolution_time_threshold: rtThreshold,\n    created_at: createdAt,\n  } = appliedSla;\n\n  const {\n    first_reply_created_at: firstReplyCreatedAt,\n    waiting_since: waitingSince,\n    status,\n  } = chat;\n\n  const SLATypes: {\n    [key: string]: { threshold: number | null; condition: boolean };\n  } = {\n    FRT: {\n      threshold: calculateThreshold(createdAt, frtThreshold),\n      //   Check FRT only if threshold is not null and first reply hasn't been made\n      condition:\n        frtThreshold !== null &&\n        (!firstReplyCreatedAt || firstReplyCreatedAt === 0),\n    },\n    NRT: {\n      threshold: calculateThreshold(waitingSince, nrtThreshold),\n      // Check NRT only if threshold is not null, first reply has been made and we are waiting since\n      condition:\n        nrtThreshold !== null && !!firstReplyCreatedAt && !!waitingSince,\n    },\n    RT: {\n      threshold: calculateThreshold(createdAt, rtThreshold),\n      // Check RT only if the conversation is open and threshold is not null\n      condition: status === 'open' && rtThreshold !== null,\n    },\n  };\n\n  const SLAStatus = SLATypes[type];\n  return SLAStatus ? { ...SLAStatus, type } : null;\n};\n\n/**\n * Evaluates SLA conditions and returns an array of SLAStatus objects.\n * @param appliedSla - The applied SLA details.\n * @param chat - The chat details.\n * @returns An array of SLAStatus objects.\n */\nconst evaluateSLAConditions = (\n  appliedSla: AppliedSla,\n  chat: Conversation\n): {\n  threshold: number;\n  type: string;\n  icon: string;\n  isSlaMissed: boolean;\n}[] => {\n  // Filter out the SLA based on conditions and update the object with the breach status(icon, isSlaMissed)\n  const SLATypes = ['FRT', 'NRT', 'RT'];\n  return SLATypes.map(type => createSLAObject(type, appliedSla, chat))\n    .filter(\n      (\n        SLAStatus\n      ): SLAStatus is { threshold: number; type: string; condition: boolean } =>\n        !!SLAStatus && SLAStatus.condition\n    )\n    .map(SLAStatus => ({\n      ...SLAStatus,\n      icon: SLAStatus.threshold <= 0 ? 'flame' : 'alarm',\n      isSlaMissed: SLAStatus.threshold <= 0,\n    }));\n};\n\n/**\n * Evaluates the SLA status for a given chat and applied SLA.\n * @param {Object} params - The parameters object.\n * @param params.appliedSla - The applied SLA details.\n * @param params.chat - The chat details.\n * @returns An object containing the most urgent SLA status.\n */\nexport const evaluateSLAStatus = ({\n  appliedSla,\n  chat,\n}: {\n  appliedSla: AppliedSla;\n  chat: Conversation;\n}): { type: string; threshold: string; icon: string; isSlaMissed: boolean } => {\n  if (!appliedSla || !chat)\n    return { type: '', threshold: '', icon: '', isSlaMissed: false };\n\n  // Filter out the SLA and create the object for each breach\n  const SLAStatuses = evaluateSLAConditions(appliedSla, chat) as SLAStatus[];\n\n  // Return the most urgent SLA which is latest to breach or has missed\n  const mostUrgent = findMostUrgentSLAStatus(SLAStatuses);\n  return mostUrgent\n    ? {\n        type: mostUrgent?.type,\n        threshold: formatSLATime(\n          mostUrgent.threshold <= 0\n            ? -mostUrgent.threshold\n            : mostUrgent.threshold\n        ),\n        icon: mostUrgent.icon,\n        isSlaMissed: mostUrgent.isSlaMissed,\n      }\n    : { type: '', threshold: '', icon: '', isSlaMissed: false };\n};\n","import isToday from 'date-fns/isToday';\nimport isYesterday from 'date-fns/isYesterday';\n/**\n * @name Get contrasting text color\n * @description Get contrasting text color from a text color\n * @param bgColor  Background color of text.\n * @returns contrasting text color\n */\nexport const getContrastingTextColor = (bgColor: string): string => {\n  const color = bgColor.replace('#', '');\n  const r = parseInt(color.slice(0, 2), 16);\n  const g = parseInt(color.slice(2, 4), 16);\n  const b = parseInt(color.slice(4, 6), 16);\n  // http://stackoverflow.com/a/3943023/112731\n  return r * 0.299 + g * 0.587 + b * 0.114 > 186 ? '#000000' : '#FFFFFF';\n};\n\n/**\n * @name Get formatted date\n * @description Get date in today, yesterday or any other date format\n * @param date  date\n * @param todayText  Today text\n * @param yesterdayText  Yesterday text\n * @returns formatted date\n */\nexport const formatDate = ({\n  date,\n  todayText,\n  yesterdayText,\n}: {\n  date: string;\n  todayText: string;\n  yesterdayText: string;\n}) => {\n  const dateValue = new Date(date);\n  if (isToday(dateValue)) return todayText;\n  if (isYesterday(dateValue)) return yesterdayText;\n  return date;\n};\n\n/**\n * @name formatTime\n * @description Format time to Hour, Minute and Second\n * @param timeInSeconds  number\n * @returns formatted time\n */\n\nexport const formatTime = (timeInSeconds: number) => {\n  let formattedTime = '';\n  if (timeInSeconds >= 60 && timeInSeconds < 3600) {\n    const minutes = Math.floor(timeInSeconds / 60);\n    formattedTime = `${minutes} Min`;\n    const seconds = minutes === 60 ? 0 : Math.floor(timeInSeconds % 60);\n    return formattedTime + `${seconds > 0 ? ' ' + seconds + ' Sec' : ''}`;\n  }\n  if (timeInSeconds >= 3600 && timeInSeconds < 86400) {\n    const hours = Math.floor(timeInSeconds / 3600);\n    formattedTime = `${hours} Hr`;\n    const minutes =\n      timeInSeconds % 3600 < 60 || hours === 24\n        ? 0\n        : Math.floor((timeInSeconds % 3600) / 60);\n    return formattedTime + `${minutes > 0 ? ' ' + minutes + ' Min' : ''}`;\n  }\n  if (timeInSeconds >= 86400) {\n    const days = Math.floor(timeInSeconds / 86400);\n    formattedTime = `${days} Day`;\n    const hours =\n      timeInSeconds % 86400 < 3600 || days >= 364\n        ? 0\n        : Math.floor((timeInSeconds % 86400) / 3600);\n    return formattedTime + `${hours > 0 ? ' ' + hours + ' Hr' : ''}`;\n  }\n  return `${Math.floor(timeInSeconds)} Sec`;\n};\n\n/**\n * @name trimContent\n * @description Trim a string to max length\n * @param content String to trim\n * @param maxLength Length of the string to trim, default 1024\n * @param ellipsis Boolean to add dots at the end of the string, default false\n * @returns trimmed string\n */\nexport const trimContent = (\n  content: string = '',\n  maxLength: number = 1024,\n  ellipsis: boolean = false\n) => {\n  let trimmedContent = content;\n  if (content.length > maxLength) {\n    trimmedContent = content.substring(0, maxLength);\n  }\n  if (ellipsis) {\n    trimmedContent = trimmedContent + '...';\n  }\n  return trimmedContent;\n};\n\n/**\n * @name convertSecondsToTimeUnit\n * @description Convert seconds to time unit\n * @param seconds  number\n * @param unitNames  object\n * @returns time and unit\n * @example\n * convertToUnit(60, { minute: 'm', hour: 'h', day: 'd' }); // { time: 1, unit: 'm' }\n * convertToUnit(60, { minute: 'Minutes', hour: 'Hours', day: 'Days' }); // { time: 1, unit: 'Minutes' }\n */\n\nexport const convertSecondsToTimeUnit = (\n  seconds: number,\n  unitNames: { minute: string; hour: string; day: string }\n) => {\n  if (seconds === null || seconds === 0) return { time: '', unit: '' };\n  if (seconds < 3600)\n    return { time: Number((seconds / 60).toFixed(1)), unit: unitNames.minute };\n  if (seconds < 86400)\n    return { time: Number((seconds / 3600).toFixed(1)), unit: unitNames.hour };\n  return { time: Number((seconds / 86400).toFixed(1)), unit: unitNames.day };\n};\n","/**\n * Creates a typing indicator utility.\n * @param onStartTyping Callback function to be called when typing starts\n * @param onStopTyping Callback function to be called when typing stops after delay\n * @param idleTime Delay for idle time in ms before considering typing stopped\n * @returns An object with start and stop methods for typing indicator\n */\n\ntype CallbackFunction = () => void;\ntype Timeout = ReturnType<typeof setTimeout>;\n\nexport const createTypingIndicator = (\n  onStartTyping: CallbackFunction,\n  onStopTyping: CallbackFunction,\n  idleTime: number\n) => {\n  let timer: Timeout | null = null;\n\n  const start = (): void => {\n    if (!timer) {\n      onStartTyping();\n    }\n    reset();\n  };\n\n  const stop = (): void => {\n    if (timer) {\n      clearTimeout(timer as Timeout);\n      timer = null;\n      onStopTyping();\n    }\n  };\n\n  const reset = (): void => {\n    if (timer) {\n      clearTimeout(timer as Timeout);\n    }\n    timer = setTimeout(() => {\n      stop();\n    }, idleTime) as Timeout;\n  };\n\n  return { start, stop };\n};\n","// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\n\n/**\n * @func Callback function to be called after delay\n * @delay Delay for debounce in ms\n * @immediate should execute immediately\n * @returns debounced callback function\n */\nexport const debounce = (\n  func: (args: any) => void,\n  wait: number,\n  immediate?: boolean\n) => {\n  let timeout: number | undefined | null;\n\n  return function() {\n    const context = null;\n    const args = arguments;\n    const later = function() {\n      timeout = null;\n      if (!immediate) func.apply(context, args as any);\n    };\n    const callNow = immediate && !timeout;\n    clearTimeout(timeout as number);\n    timeout = window.setTimeout(later, wait);\n    if (callNow) func.apply(context, args as any);\n  };\n};\n","/**\n * Function that parses a string boolean value and returns the corresponding boolean value\n * @param {string | number} candidate - The string boolean value to be parsed\n * @return {boolean} - The parsed boolean value\n */\n\nexport function parseBoolean(candidate: string | number) {\n  try {\n    // lowercase the string, so TRUE becomes true\n    const candidateString = String(candidate).toLowerCase();\n\n    // wrap in boolean to ensure that the return value\n    // is a boolean even if values like 0 or 1 are passed\n    return Boolean(JSON.parse(candidateString));\n  } catch (error) {\n    return false;\n  }\n}\n"],"names":["sortAsc","arr","slice","sort","a","b","clamp","min","max","value","_quantileForSorted","sorted","q","clamped","pos","length","base","Math","floor","undefined","MESSAGE_VARIABLES_REGEX","capitalizeName","name","replace","s","toUpperCase","getFirstName","user","firstName","split","shift","getLastName","lastName","pop","calculateThreshold","timeOffset","threshold","Date","now","formatSLATime","seconds","units","y","mo","d","h","m","parts","Object","keys","forEach","unit","push","join","unitNames","time","Number","toFixed","minute","hour","day","onStartTyping","onStopTyping","idleTime","timer","stop","clearTimeout","start","setTimeout","func","wait","immediate","timeout","context","args","arguments","later","apply","callNow","window","appliedSla","chat","type","icon","isSlaMissed","SLAStatuses","mostUrgent","map","frtThreshold","sla_first_response_time_threshold","nrtThreshold","sla_next_response_time_threshold","rtThreshold","sla_resolution_time_threshold","createdAt","created_at","firstReplyCreatedAt","first_reply_created_at","waitingSince","waiting_since","status","SLAStatus","FRT","condition","NRT","RT","createSLAObject","filter","evaluateSLAConditions","sla1","sla2","abs","date","todayText","yesterdayText","dateValue","isToday","isYesterday","timeInSeconds","formattedTime","minutes","hours","days","bgColor","color","parseInt","conversation","meta","assignee","sender","id","custom_attributes","conversationCustomAttributes","contactCustomAttributes","contact","email","phone_number","entries","reduce","acc","data","intervals","interval","variables","matches","message","match","trim","variable","candidate","candidateString","String","toLowerCase","Boolean","JSON","parse","error","_","content","maxLength","ellipsis","trimmedContent","substring"],"mappings":"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"}